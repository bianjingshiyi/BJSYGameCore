8/21:
整理一下触发器流程：
首先有ITriggerEvent或者ITriggerEventSource，ITriggerEvent是单个事件，ITriggerEventSource是多个事件。单个事件有事件名，多个事件也有事件名，两者都可以注册触发器，并且会在被触发的时候调用。
考虑ITriggerEvent与ITriggerScope整合，可以获取局部变量和方法库。
8/24:
先考虑整个触发器如何运作。
触发器被某个事件来源调用，根据事件来源的不同，事件来源本身可能提供事件中的变量。
反射动作的定义取决于它们执行时所在的作用域，反射动作会在作用域中查询自己对应的方法。
作用域会提供额外的变量和动作，比如“枚举对象”和“退出枚举”。

应用场景：
当技能被释放 —— 提供变量“施法单位”和“目标地点”
选取范围内单位 —— 提供变量“枚举单位”和动作“退出枚举”
对枚举单位造成500伤害 —— 枚举单位查询到枚举作用域获得值，伤害动作查询到技能作用域获得方法。

事件源调用触发器invoke，动作查询作用域自身效果。

问题：
不管是变量还是动作，都没有办法自身存储值或者反射方法，它们肯定要通过作用域得到某种东西才能产生效果。
这个东西可以是通过反射生成的，也可以是直接写的，比如内置的。
这里还有一个动态和静态的问题，调用触发器的过程是动态的，针对“退出循环”这种东西，作用域是动态生成的，这样才能避免出现BUG。
但是在编辑器中，需要静态的作用域才能得到作用域所提供的动作和函数。

应用场景：
添加动作：首先要获取事件来源，事件来源意味着作用域，通过作用域获取可用的动作。
设置参数：通过作用域获取指定类型的可选函数。